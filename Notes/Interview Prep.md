- Notes
    - Interview stages
        - Cultural Interview
            - Typically cultural interviews start with “So tell me about yourself.” It’s imperative to have a well thought out response to this question.
            - Take notes. You’ll probably have a lot of interviews, and it’s important to keep them all straight!
            - Don’t ask about minute specifics of salary or benefits, wait until you have an offer to sort that out.
            - Be yourself. You want to make sure the company culture harmonizes with your personality.
        - Recruiter phone call
            - Ask the recruiter about the format of the interview
                - practice in the environment that your interview is going to take place in
            - Ask your recruiter for more information about the topics you should study up on.
            - Read up on the role and the company
                - have a general understanding of the role you’ve applied for
                - keep the applications organized in a document
                    - company name
                    - recruiter name
                    - email address
                    - link to the application
                    - pertinent details.
                    - what their values are
                    - what they’re currently working on
            - Be on time
                - If it's a digital meeting, be 5 minutes early to sort out technical issues
                - If it's over the phone, put phone on DND and be in a quiet place
            - "Tell me about yourself"
                - Have a short story prepared to illustrate who you are
                - Have 1–2 stories which demonstrate your greatest achievement and a difficult problem you solved
                - Be honest about your skill set.
            - Don’t bash your current, or past, employers, it shows a lack of respect.
            - Have a few questions prepared
                - Examples:
                    - A good format would be: “I saw your company just did X… how will this impact Y?”
                    - What is the culture like in the office?
                    - How is the diversity at your company?
                    - Are there opportunities for continuing education such as a conference allowance or subscriptions to learning platforms?
                    - How is the work/life balance?
        - Coding Challenge
            - During this call you’ll pair up with a developer who will give you a coding challenge.
            - Can be 2 or 3 small questions or one large question
            - Coding challenges aim to test the breadth of your web development knowledge whilst the on-site interviews and/or coding projects aim to test vertical data structures and algorithms knowledge, however take this with a grain of salt.
            - Think out loud. It’s important for the interviewer to hear your thought process!
            - If you’re unclear about one of the directions, ask. Sometimes interviewers will even give you a hint.
            - Fail fast and often. Always try your ideas, and when they don’t work, learn from them and iterate.
            - If you’ve received an interview question before, and know the solution, you should let your interviewer know. If you know the solution step-by-step the interviewer will be able to tell you looked up the answer (or previously figured it out). Honesty is always the best policy.
            - If you have a solution, try to improve the performance or run-time. Optimization is key.
            - If you don’t know the answer, it’s okay. I would often admit: “To be honest, I’m not sure, but if I had to make an educated guess…” I’ve seen candidates fully bullshit their way through a question, and pretend it’s right as rain. In my opinion it’s better to admit when you don’t know, but give an educated guess.
            - If you can’t remember the syntax, be honest. Honesty is always the best policy.
        - Coding Project
            - What is a coding project?
                - An encapsulated prompt that asks you to build a small application.
                - Some companies might provide you with a few options to choose from that test different skills. Others might provide you with one prompt.
                - You might get a link to a General Assembly challenge that you have to complete online. These are occasionally timed, but try not to let that freak you out.
                - Or, you may get asked to recreate a piece of the company’s application.
            - Clarify Requirements
                - Does the company want you to use a specific technology stack?
                - How do they want to receive the deliverables?
                    - Private GitHub repository?
                    - .zip file sent through email?
                    - Hosted as a website with a password?
            - Set up version control
            - Thoroughly Document
                - The project reviewer should be able to quickly and easily locate installation instructions for cloning and running your application.
                - Can be a README, a PDF document, or a website, however you should clarify how the company prefers to receive these deliverables.
            - Create User Flows
                - Clarify information architecture
                - Sketch out different flows the user can take (like sign in or edit preferences)
                - Include user flows or information architecture documents within your final deliverables.
                - This will showcase your conscious attention to the end user.
            - Add Additional Enhancements or Features
                - Doesn’t have to be fully-functional (it can be hard-coded data)
                - If you don’t have time to implement the features, you can list them with a high-level description of what the features do and why they enhance the user experience.
            - Note Areas For Improvement
                - Show that a candidate is self-aware and recognizes areas that can be improved.
                - Great way to showcase your knowledge without having to spend hours implementing features or refactoring code.
            - Remove Code Comments
                - Once completing your project you should wait several hours (or better yet sleep on it) and then take a fresh read through your code. Are there any lingering code comments? Can you remove them?
            - Refactor Non-Performant Code
                - If there are areas of your code that aren’t performant (a nested for-loop for example), try to optimize them. Show your reviewers that you prioritize performance.
            - Test For Accessibility
                - Before submitting, run your application through an accessibility tool like Lighthouse or Axe.
                - Fixing small accessibility pitfalls and including a small paragraph explaining your mindful care of accessibility will set you apart from the crowd.
            - Design A Logical Project Architecture
                - How do you want to organize your project files?
                - Be consistent with your naming conventions and architect your code logically.
            - Questions To Ask Yourself Before Submission:
                - Did I meet all of the project requirements?
                - Is my solution performant?
                - Is my solution responsive/mobile friendly?
                - Is my solution accessible?
                - Is my solution appealing to look at?
                - Is my code clean and efficient?
                - Am I proud of this solution?
            - Tips For The Take Home Challenge:
                - Don’t spend more than a day on it.
                    - If you’re spending several days on it, most likely you should go back and work on some of your technical skills.
                - It’s okay to pull yourself out of the candidate pool.
                    - I have had interviews in the past where I’ve had to email the recruiter and tell them that my skills weren’t where they needed to be. This shows them a level of self-awareness. I have even had recruiters come back to me several times to see if I was still interested in an interview. It’s okay to admit when you have areas to improve upon. Plus, you don’t want to stress yourself out with a challenge that is too difficult, because when you get a job offer, chances are the job will stress you out just as much.
                - If you need additional time, just ask.
                    - Recruiters know that you’re busy, and as such life can get in the way of an interview. So instead of half-assing your take home challenge, email the interviewer and let them know that this is extremely important to you, and you want to devote a proper amount of time to completing it. Most companies would prefer you spend a few more days on an assessment than sacrifice the quality.
        - On-Site Interview
            - Tips for On-Site Interviews
                - Wear Comfortable & Smart Clothing
                    - You want to balance looking professional yet approachable with feeling comfortable. If you don’t normally wear high heels or a suit, don’t pick the day of your on-site interview to try it out for the first time! Choose clothing that will put you at ease while still conveying your professionalism.
                - Take Bathroom Breaks
                    - This may sound strange but taking a moment to decompress in the bathroom will help you reset your mind between interviews, especially if you had an interview that didn’t go as planned. Take two minutes and breathe. Clear your mind. It will help you begin the next interview with a clean canvas.
                - Visit The Building The Day Before The Interview
                    - If you’re able to visit the campus or building the day before I highly recommend doing so. The morning of your on-site interview you’ll likely be a little stressed out so focus on removing all of the obstacles or stressers you have control over.
                    - If you can’t visit the site the day before, give yourself an extra 30 to 45 minutes to be early. Often these buildings and campuses can be a bit tricky to locate.
            - Types of Interviews
                - Data structures & algorithms interviews
                    - The data structures and algorithms interviews test knowledge that is primarily taught during a computer science degree
                    - Potential Topics Covered
                        - Data structures
                            - Stacks
                            - Queues
                            - Linked Lists
                            - Graphs
                            - Trees
                            - Tries
                        - Sorting Algorithms
                            - Merge sort
                            - Quick sort
                            - Insertion sort
                        - Searching Algorithms
                            - Binary search
                            - Depth-first search
                            - Breadth-first search
                            - Tree traversals
                        - Concepts
                            - Big-O Notation
                            - Recursion
                - Front-end interviews
                    - These interviews cover web technologies and the questions you’ll receive will likely test practical situations you may encounter during your day-to-day responsibilities.
                    - Potential Topics Covered
                        - HTML
                            - Semantic HTML
                            - Accessibility / ARIA
                        - CSS
                            - Specificity
                            - Pseudo-elements / pseudo-selectors
                            - Position
                            - Display
                            - Media queries
                            - Animations
                        - JS
                            - Data structures (i.e. maps, sets, symbols, arrays)
                            - Closures
                            - Asynchronous programming
                            - DOM manipulation
                            - Event delegation
                        - The Internet
                            - TCP/IP
                            - CORS
                            - Performance
                        - UX/UI
                            - Information architecture
                            - User flows
                            - UX heuristics
                - Process & communication interviews
                    - During this interview a hiring manager, engineer, scrum master, or someone else from the team will ask you questions about collaboration and workflow.
                    - Here are some things to keep in mind for process and communication interviews.
                        - Sit up straight and make eye contact
                        - Don’t fidget
                        - Think before answering; it’s okay to take a quick pause to iron out your answer before jumping into it.
                        - Never speak poorly about your previous or current employer
                    - Here are several examples of questions you might receive in the process and communication interview. Try to come up with your own answers to these questions. Write them down and practice speaking them out loud. You want your answers to be well-spoken but not sound rehearsed.
                        - Tell me about a project that failed. Why did it fail and how did you handle it?
                            - Potential Answer
                                - Last year I started a project with the goal of improving mentorship in the tech industry. Unfortunately the project required a lot of my time and I wasn’t able to commit 20 hours a week to keep it running so I had to put it on hold.
                                - I’m still passionate about mentorship so I decided to mentor two developers and write blog posts to share my knowledge. Even though my project is currently on hold I’m able to mentor others through my writing.
                                - I hope to continue the project one day.
                        - How would you handle a situation in which your coworker has a different opinion on how to develop a new feature?
                            - Potential Answer
                                - I would first try to understand why my coworker is so adamant about their particular solution. I would schedule a time with them one on one where we can discuss the conflict. We would do this in private and at a scheduled time to ensure we’ve created a safe space for a discussion.
                                - What benefits does this solution provide that mine does not? Maybe their solution ultimately is better. If I listen and still disagree I would explain my point of view. If we still can’t come to an agreement we can bring in a neutral party like a team lead to make the final decision.
                        - Why are you looking to leave your current job?
                            - Potential Answer
                                - I enjoy my current company but I’m looking to move into a role which allows me to accomplish X. I believe I can do that here.
                            - Potential Answer
                                - I’m looking for a smaller company where I can make more of an impact. Working in a large company has been great and I’ve learned many skills but I’m ready to take on more responsibility within a smaller team.
                        - What are you looking for in your next role?
                            - Potential Answer
                                - I’m looking for a company where I am surrounded by diverse coworkers who are passionate about what they do.
                            - Potential Answer
                                - I’m looking for a company where I can grow my skills through mentorship and continued education (i.e. conferences, online learning platforms).
                - Manager / team matching interviews
                    - During your interview process you may meet with a potential manager or team. During these meetings it’s important to have a few questions prepared regarding the role.
                    - Here are some sample questions you may want to ask.
                        - What technology stack is the team using?
                        - Does the team iterate on sprints? If so, how long are sprints? One week? Two weeks? Four?
                        - What opportunities are there to expand my knowledge? Will I have the opportunity to attend conferences or take online courses?
                        - Is there an opportunity for mentorship?
        - Getting an offer
            - Ask how long you can think about it. Most managers will give you around a week to give an answer.
            - It’s okay to say no. If you don’t think this job will make you happy, then don’t take it!
            - Ask if relocation assistance is available. If you’re moving across the country, lack of financial assistance may be a deal breaker.
        - Negotiating
            - Why negotiate?
                - You could potentially leave a lot of money and benefits on the table.
                - Your co-workers negotiated. They didn’t feel guilty negotiating, and you shouldn’t either.
                - You don’t have to solely negotiate salary either
                    - Paid time off
                    - Stock options
                    - Flexible working hours
            - If You’re Happy With The Offer
                - You don’t _have_ to negotiate
                - Typically a company doesn’t make their best offer first, but some do
                - If you're happy with the offer, you still win!
            - If You’re Not Happy With The Offer
                - If company isn’t willing to negotiate, you have to decide whether to accept the offer.
                - Some people have the luxury of being able to choose between multiple offers while others won’t be able to pay their bills if they don’t accept.
            - Negotiation template
                - Greeting
                - Thank hiring manager for considering you
                - Reiterate that you're excited to have been considered
                - Which benefits you want to negotiate
                - Mention other offers you may have
                - Reiterate skills and experience
                - Explain the benefit you're looking for
                - Discuss how you would be a benefit to the company
                - "I would love to sign an offer today"
                - Signoff
        - Dealing with rejection
            - Everyone gets rejected, everyone.
            - Rejection doesn't mean you weren't good enough.
            - You can always re-apply to that company in the future.
            - Let yourself feel those feelings and don’t diminish them.
            - Think about how proud of yourself you’ll feel once you do receive an offer.
            - You’ll get there. You can do this.
    - Problem solving
        - Understand the problem
            - Many questions are left intentionally incomplete as the interviewer wants to see your ability to deduce what information is incomplete or missing.
            - A good way to ensure you understand the problem is to reiterate it to the interviewer.
        - List functional requirements
            - Listing the requirements will
                - help you understand the problem
                - ensure you don’t get sidetracked
                - identify missing information
                - allow you to focus on the tasks of most importance
        - List possible solutions
            - Are there any data structures you need to use? If so, what are the benefits and drawbacks of each? Speak your thoughts out loud and write down a few possible paths you can take.
            - Once you have two or three possibilities, choose the solution that you’re most comfortable coding. If it’s not the most performant or optimal solution that’s okay. State that out loud.
            - There’s nothing wrong with coding a brute-force solution first and optimizing second.
        - Optimize your solution
            - If you have time, optimize your code.
            - If you don’t have time, explicitly state that you recognize this solution isn’t performant and you would have liked to refactor it
        - Test your solution
            - Even if you “know” your solution is 110% correct, test it.
            - Think about the edge cases
                - What happens with your code when it’s passed an argument it didn't expect? Does it break? If so, refactor.
        - If you get stuck
            - Be honest with your interviewer
            - "I know I need to do X but I'm not sure how to proceed."
            - Your interviewer wants you to succeed, they'll be happy to give you a hint or two
            - Stay calm, breathe, take a drink of water
    - Data Structures
        - What is a Data Structure?
            - an organization of data such that it can be accessed and modified in a particular manner
            - Many of the data structures you’ll need for your technical interviews are not natively built into JavaScript.
        - Stacks
            - ![[Screenshot 2023-09-12 at 12.54.14 PM.png]]
                - A “last-in-first-out” data structure which means that the newest element (or the element which was added last) in the stack will be the first one removed.
                - Think of it like a stack of books
                    - To get the 3rd book, first we have to remove the fifth book, then the fourth
            - Benefits of stacks
                - Allow for constant-time ( O(1) ) adding and removing of the top item
                    - These actions are constant-time because we don’t need to shift any items around to pop off the top item in the stack.
            - Downsides of stacks
                - Stacks don’t offer constant-time access to the nth item in the stack, unlike an array
                - If you want to access the first item in the stack, you'd have to pop off every other item in the stack in order first
                    - Unlike an array where you can access the nth item in the array in constant-time using bracket notation, e.g. `myArray[2]`
                - has a worst-case runtime of O(n) where n is the number of books in the stack.
            - Stack methods
                - `pop()`
                    - Removes the top item in the stack
                - `push(item)`
                    - Adds the given item to the top of the stack
                - `peek()`
                    - Returns the item at the top of the stack (but does not remove it)
                - `isEmpty()`
                    - Returns true if the stack is empty
                - `get length()`
                    - Returns the number of items in the stack
            - Code Examples
                - Class notation  
                    ```class Stack {  
                    constructor () {  
                    this.stack = [];  
                    }  
                    pop() {  
                    return this.stack.shift();  
                    }  
                    push(item) {  
                    this.stack.unshift(item);  
                    }  
                    peek() {  
                    return this.stack[0];  
                    }  
                    isEmpty() {  
                    return this.stack.length === 0;  
                    }  
                    get length() {  
                    return this.stack.length;  
                    }  
                    }```
                - Function notation  
                    ```  
                    function Stack () {  
                    this.stack = [];  
                    }  
                    Object.defineProperty(fStack.prototype, "length", {  
                    get: function () {  
                    return this.stack.length;  
                    }  
                    });  
                    fStack.prototype.pop = function () {  
                    this.stack.shift();  
                    }  
                    fStack.prototype.push = function (item) {  
                    this.stack.unshift(item);  
                    }  
                    fStack.prototype.peek = function () {  
                    return this.stack[0];  
                    }  
                    fStack.prototype.isEmpty = function () {  
                    return this.stack.length === 0;  
                    }  
                    ```
            - Usage Example:
                - Imagine you’re building a navigation component for a product website we’ll call “Rainforest”. Users can navigate from the home page to different product pages within the site. For example, a user flow might be Home > Kitchen > Small Appliances > Toasters.
                - Build a navigation component that displays the list of previously visited pages as well as a back button which lets the user go back to the previous page.
                - A stack would be an optimal solution for this question because the top-most item in a stack is the most recently added item (in this case the last page that was visited). So when we want to navigate backwards, we can pop off the last item in the stack and render the state of the previous page.
                - Your solution should display a navigation with four links, a history list that displays the previously visited pages, a current page paragraph which displays the name of the currently displayed page, and a go back button which, when clicked, navigates to the previously visited page.
                - Here are some additional error boundaries to think about:
                    - What happens if you don’t have any previously visited pages?
                    - What happens if you’re already on a page and you try navigating to it?
                - Now that you’ve accounted for some special use cases, are there any enhancements you could make to optimize performance or the user experience?
                - Follow-up questions
                    - Often during coding challenges, you’ll be posed with an initial question and if you finish a piece of it the interviewer will ask some follow-up questions. Here are a couple of followups you might encounter for this question. Often you’re not expected to complete all pieces of the question or get them completely correct: these challenges are more to discover how you problem solve and communicate.
                    - Expand your solution to be able to navigate forwards as well as backwards. Here are a few example user flows which will help you develop your solution:
                        - User flow 1: Home Home > Kitchen Home > Kitchen > Bathroom _Back_ Home > Kitchen > Home > Kitchen > Living room
                        - User flow 2: Home Home > Kitchen Home > Kitchen > Bathroom Back Home > Kitchen > _Forward_ Home > Kitchen > Bathroom Home > Kitchen > Bathroom > Home
                        - User flow 3: Home Home > Kitchen Home > Kitchen > Bathroom _Back_ Home > Kitchen _Back_ Home _Forward_ Home > Kitchen _Forward_ Home > Kitchen > Bathroom
        - Queues
            - What is a Queue?
                - Similar to stacks however they use the “first-in-first- out” paradigm.
                    - The oldest element (the element that was added first) is the next item to be removed.
                - Picture a queue like a queue of people waiting to buy movie tickets.
                    - The person who has been waiting in line the longest is the next person to be serviced.
                - ![[Screenshot 2023-09-12 at 12.54.51 PM.png]]
            - Use-Cases for Queues
                - Queues are similar to linked lists (which we’ll cover next) and are typically used in breadth-first searches for trees (which we’ll also cover in a subsequent section). You may also see queues being used to implement cache.
            - Downsides of Queues
                - Queues are much more difficult to update when adding and removing items than a stack because we’re adding items to one side of the structure and removing them from the other side.
            - Queue methods
                - `enqueue()`
                    - Add an item to the back of the queue
                - `dequeue()`
                    - Remove an item from the front of the queue
                - `peek()`
                    - Return the item at the front of the queue (but do not remove it)
                - `isEmpty()`
                    - Check whether the queue is empty
                - `get length`
                    - Return the length of the queue
            - Code Examples
                - Class notation  
                    ```  
                    class Queue {  
                    constructor () {  
                    this.queue = [];  
                    }  
                    enqueue(item) {  
                    this.queue.push(item);  
                    }  
                    dequeue() {  
                    return this.queue.shift();  
                    }  
                    peek() {  
                    return this.queue[0];  
                    }  
                    isEmpty() {  
                    return this.queue.length === 0;  
                    }  
                      
                    get length() {  
                    return this.queue.length;  
                    }  
                    }```
                - Function notation  
                    ```  
                    function Queue () {  
                    this.queue = [];  
                    }  
                    Object.defineProperty(Queue.prototype, "length", {  
                    get: function () {  
                    return this.queue.length;  
                    }  
                    });  
                    Queue.prototype.dequeue = function () {  
                    return this.queue.shift();  
                    }  
                    Queue.prototype.enqueue = function (item) {  
                    this.queue.push(item);  
                    }  
                    Queue.prototype.peek = function () {  
                    return this.queue[0];  
                    }  
                    Queue.prototype.isEmpty = function () {  
                    return this.queue.length === 0;  
                    }```
        - Linked Lists
            - What is a Linked List?
                - ![[Screenshot 2023-09-12 at 12.55.31 PM.png]]
                - A series of linked nodes where each node points to the next node in the list
                - Each node has a value and a pointer to the next node.
                - There are also doubly-linked lists in which each node also points to the previous node in the list.
                - Linked lists use the “last-in-first-out” method (similar to a stack) where nodes are added to and deleted from the same end.
                - To search for a node in a linked list we have to start at the head node (the first node in the list) and iterate through each node until we find it or reach the end of the list. In a worst-case scenario this means that searching for an item has a runtime of O(n) where n is the number of items in the list.
            - Linked List methods
                - `push(Node)`
                    - Add an element to the linked list
                - `pop()`
                    - Remove an element from the linked list
                - `get(index)`
                    - Return an element from a given index (but don't remove it)
                - `delete(index)`
                    - Delete an item from a given index
                - `isEmpty()`
                    - Return a boolean indicating whether the list is empty
            - Singly-Linked Lists vs. Doubly-Linked Lists
                - In a singly-linked list, each node has one pointer which points to the next element in the list.
                - In a doubly-linked list, each node has two pointers:
                    - one which points to the next element in the list
                    - one which points to the previous element in the list
                - Doubly-linked lists are great for removing nodes because they provide access to the previous and the next nodes.
                - To remove a node from a singly-linked list, we have to iterate through the list, keeping track of the previous node so it’s a bit more complicated.
            - Code Examples (Singly-linked list)
                - `Node` class
                    - Nodes have a value and a pointer to the next node
                    - For doubly-linked lists, they also have a pointer to the previous node;
                    - When we create a new node we will pass the value to the constructor.
                    - We will also initialize the pointer to null (as we’re adding this node to the end of the list).
                    - Example:  
                        ```  
                        class Node {  
                        constructor (value) {  
                        this.value = value;  
                        this.next = null;  
                        }  
                        }  
                        ```
                - `LinkedList` class
                    - The constructor will keep track of three things:
                        - `head` : Pointer to the first node in the linked list
                        - `tail` : Pointer to the last node in the linked list
                        - `length` : The number of nodes in the list
                    - The head and tail pointers will be null until we add our first node.
                    - Example:  
                        ```class LinkedList {  
                        constructor () {  
                        this.head = null;  
                        this.tail = null;  
                        this.length = 0;  
                        }  
                        }```
                - `isEmpty()` method
                    - Returns true if there are no nodes in the list
                    - Example:  
                        ```  
                        isEmpty() {  
                        return this.length === 0;  
                        }```
                - `push(value)`method
                    - Accepts a value and creates a new `Node` with that value
                    - if the list is empty
                        - Set `head` to the new node
                        - Set `tail` to the new node
                        - ![[Screenshot 2023-09-12 at 12.55.51 PM.png]]
                    - if the list has at least 1 node
                        - Set the `.next` property of the `.tail` node to the new node
                        - Set `tail` to the new node
                        - ![[Screenshot 2023-09-12 at 12.56.06 PM.png]]
                    - Increment `length` by 1
                    - Example:  
                        ```  
                        push (value) {  
                        var newNode = new Node(value);  
                          
                        if (this.isEmpty()) {  
                        this.head = newNode;  
                        this.tail = newNode;  
                        } else {  
                        this.tail.next = newNode;  
                        this.tail = newNode;  
                        }  
                          
                        this.length++;  
                        }  
                        ```
                - `pop(value)` method
                    - If the list is empty
                        - return `null`
                    - If there is only one node in the list
                        - You can check if this is the case by either:
                            - Checking if `this.head === this.tail`
                            - Chicking if `this.length === 0`
                        - set `head` to `null`
                        - set `tail` to `null`
                        - set `length` to `0`
                        - ![[Screenshot 2023-09-12 at 12.56.22 PM.png]]
                    - If there is more than one node in the list
                        - Create a `currentNode` variable
                        - Create a `nodeToReturn` variable
                        - Iterate through the nodes one at a time
                            - For each node, check if it's `.next` property is equal to `this.tail`. If it is...
                                - Update `this.tail` to the current node
                                - Set the new `tail` node's `.next` property to `null`
                                - Decrement `length` of the list by 1
                                - Return the previous `tail` element
                    - Example  
                        ``` pop () {  
                        // check if the list is empty  
                        if (this.isEmpty()) {  
                        // if it is, there's nothing to return  
                        return null;  
                        } else if (this.length === 1) {  
                        // if there's only one item,  
                        // reset head and tail and return the node  
                        let nodeToRemove = this.head;  
                        this.head = null;  
                        this.tail = null;  
                        // don't forget to decrement the list!  
                        this.length--;  
                        return nodeToRemove;  
                        } else {  
                        // if there's more than one node, we need to find the second-to-last node  
                        // start with the head  
                        let currentNode = this.head;  
                        // we'll be returning the current tail  
                        let nodeToRemove = this.tail;  
                        // the second to last node will be the new tail  
                        let secondToLastNode;  
                          
                        // traverse the list one node at a time  
                        while (currentNode) {  
                        // if the next node is the tail, store the current node  
                        if (currentNode.next === this.tail) {  
                        // we've found our new tail  
                        secondToLastNode = currentNode;  
                        break;  
                        }  
                        // otherwise, move on to the next node in the list  
                        currentNode = currentNode.next;  
                        }  
                          
                        // make the old second to last node the new tail  
                        secondToLastNode.next = null;  
                        this.tail = secondToLastNode;  
                        // seriously, don't forget to decrement the list  
                        this.length--;  
                        // now that we've removed the old tail node, we can return it  
                        return nodeToRemove;  
                        }  
                        }```
                - `get(index)` method
                    - Check if the passed `index` is valid. It's **not** valid if
                        - It's not a number
                        - It's less than 0
                        - It's greater than `length - 1`
                        - The list is empty
                    - If we're returning the first or last node
                        - if the `index` is 0, return `head`
                        - if the `index === length - 1` return `tail`
                    - Otherwise
                        - Iterate through the nodes until you hit the `index`
                        - Return the found node
                    - Example:  
                        ```  
                        get (index) {  
                        // check if the index is valid  
                        if (  
                        typeof index !== 'number' ||  
                        index < 0 ||  
                        index > this.length ||  
                        this.isEmpty()  
                        ) {  
                        // if it is, we're not going to return a node  
                        return null;  
                        }  
                          
                        // check if we want to return the head node  
                        if (index === 0) {  
                        return this.head;  
                        }  
                          
                        // or the tail node  
                        if (index === this.length - 1) {  
                        return this.tail;  
                        }  
                          
                        // keep track of the current node using an iterator  
                        var iterator = 0;  
                        // starting at the head  
                        var currentNode = this.head;  
                          
                        // iterate through the nodes one at a time until we hit the desired index  
                        while (iterator < index) {  
                        iterator++;  
                        currentNode = currentNode.next;  
                        }  
                          
                        // once we have, return the current node  
                        return currentNode;  
                        }  
                        ```
                - `delete(index)`
                    - Similar to `get(index)` except you also need to keep track of the previous node
                    - Once you've found the node you want to return
                        - Update the previous node's `.next` property to the `.next` property of the node you're going to return, effectively removing it from the list
                    - Example:  
                        ```  
                        delete (index) {  
                        // just like with get(index), we need to check if the passed index is valid  
                        if (  
                        typeof index !== 'number' ||  
                        index < 0 ||  
                        index > this.length ||  
                        this.isEmpty()  
                        ) {  
                        return null;  
                        }  
                          
                        // if we need the head node, our job is easy  
                        if (index === 0) {  
                        let nodeToReturn = this.head;  
                        if (this.length === 1) {  
                        // if there's only one node, reset the head and tail  
                        this.head = null;  
                        this.tail = null;  
                        } else {  
                        // otherwise, the new head will be the old second node  
                        this.head = this.head.next;  
                        }  
                        // I'm not joking, you WILL forget this  
                        this.length--;  
                        return nodeToReturn;  
                        }  
                          
                        // for all other nodes, including the tail node (since we also need the one before the tail)  
                        var iterator = 0;  
                        var currentNode = this.head;  
                        // we're also going to keep track of the node before the current one  
                        var previousNode = null;  
                          
                        // iterate through the nodes til we hit the index  
                        while (iterator < index) {  
                        iterator++;  
                        // make sure you store the current node AND the previous one  
                        previousNode = currentNode;  
                        currentNode = currentNode.next;  
                        }  
                          
                        // once we hit our index, update the previous one to point at the NEXT one, i.e. the current node's .next value  
                        previousNode.next = currentNode.next;  
                          
                        // DECREMENT THE LIST DAMN YOU!  
                        this.length--;  
                          
                        return currentNode;  
                        }  
                        ```
                - Complete code:
                    - Example:  
                        ```  
                        class Node {  
                        constructor (value) {  
                        this.value = value;  
                        this.next = null;  
                        }  
                        }  
                          
                        class LinkedList {  
                        constructor () {  
                        this.head = null;  
                        this.tail = null;  
                        this.length = 0;  
                        }  
                          
                        push (value) {  
                        var newNode = new Node(value);  
                          
                        if (this.isEmpty()) {  
                        this.head = newNode;  
                        this.tail = newNode;  
                        } else {  
                        this.tail.next = newNode;  
                        this.tail = newNode;  
                        }  
                          
                        this.length++;  
                        }  
                          
                        pop () {  
                        if (this.isEmpty()) {  
                        return null;  
                        } else if (this.length === 1) {  
                        let nodeToRemove = this.head;  
                        this.head = null;  
                        this.tail = null;  
                        this.length--;  
                        return nodeToRemove;  
                        } else {  
                        let currentNode = this.head;  
                        let nodeToRemove = this.tail;  
                        let secondToLastNode;  
                          
                        while (currentNode) {  
                        if (currentNode.next === this.tail) {  
                        secondToLastNode = currentNode;  
                        break;  
                        }  
                          
                        currentNode = currentNode.next;  
                        }  
                          
                        secondToLastNode.next = null;  
                        this.tail = secondToLastNode;  
                        this.length--;  
                        return nodeToRemove;  
                        }  
                        }  
                          
                        get (index) {  
                        if (  
                        typeof index !== 'number' ||  
                        index < 0 ||  
                        index > this.length ||  
                        this.isEmpty()  
                        ) {  
                        return null;  
                        }  
                          
                        if (index === 0) {  
                        return this.head;  
                        }  
                          
                        if (index === this.length - 1) {  
                        return this.tail;  
                        }  
                          
                        var iterator = 0;  
                        var currentNode = this.head;  
                          
                        while (iterator < index) {  
                        iterator++;  
                        currentNode = currentNode.next;  
                        }  
                          
                        return currentNode;  
                        }  
                        delete (index) {  
                        if (  
                        typeof index !== 'number' ||  
                        index < 0 ||  
                        index > this.length ||  
                        this.isEmpty()  
                        ) {  
                        return null;  
                        }  
                          
                        if (index === 0) {  
                        let nodeToReturn = this.head;  
                        if (this.length === 1) {  
                        this.head = null;  
                        this.tail = null;  
                        } else {  
                        this.head = this.head.next;  
                        }  
                          
                        this.length--;  
                        return nodeToReturn;  
                        }  
                          
                        var iterator = 0;  
                        var currentNode = this.head;  
                        var previousNode = null;  
                          
                        while (iterator < index) {  
                        iterator++;  
                        previousNode = currentNode;  
                        currentNode = currentNode.next;  
                        }  
                          
                        previousNode.next = currentNode.next;  
                        this.length--;  
                        return currentNode;  
                        }  
                        isEmpty () {  
                        return this.length === 0;  
                        }  
                        }  
                        ```
        - Graphs
            - What is a graph?
                - A data structure composed of a collection of nodes and edges.
                - Graphs are a non-linear data structure (as opposed to a linked list, stack, or queue).
                - You may also hear nodes referred to as vertices.
            - What are graphs for?
                - Graphs are used to solve many real-world problems and can be used to represent networks.
            - There are 2 types of graphs
                - Directed graphs
                    - contains edges which function similarly to a one-way street; they have a direction.
                    - For example you might have a graph where people can have favorite foods but foods don’t have favorite people.
                - Undirected graphs
                    - Contains edges which flow bidirectionally, like a two-way street.
                    - For example you might have a graph of pets where people have pets and pets have owners. The relationship goes both ways.
            - Example
                - `Node` class
                    - A node keeps track of:
                        - A `value`, which is its identifier
                        - A list of `edges` for that node
                    - Example:  
                        ```class GraphNode {  
                        constructor () {  
                        this.value = null;  
                        this.edges = [];  
                        }  
                        }```
                - `Graph` class
                    - A graph keeps track of:
                        - Whether the graph is directed or undirected
                        - A list of `Node`s
                    - `addNode(value)`
                        - Create a new `Node` with the provided value
                        - `.push` the created `Node` to the nodes array
                        - Example:  
                            ```  
                            addNode (value) {  
                            this.nodes.push(new GraphNode(value));  
                            }  
                            ```
                    - `removeNode(value)`
                        - Remove the `Node` from the nodes array
                        - Iterate through the nodes array and remove the node from each `Node`'s edges array
                        - Example:  
                            ```  
                            this.nodes = this.nodes.filter(node => node.value !== value);  
                              
                            this.nodes.forEach(node => {  
                            node.edges = node.edges.filter(edge => edge.value !== value);  
                            });  
                            }  
                            ```
                    - `getNode(value)`
                        - Find the desired node in the Graph's nodes array and return it
                        - Example:  
                            ```  
                            getNode (value) {  
                            return this.nodes.find(function findNode (node) {  
                            return node.value === value;  
                            });  
                            }  
                            ```
                    - `addEdge(value1, value2)`
                        - Get the nodes that you want to add an edge between using the provided values
                        - Push the desired node to the other node's edges array
                        - If the graph is undirected, do the same in the other direction
                        - Example:  
                            ```  
                            addEdge (value1, value2) {  
                            var node1 = this.getNode(value1);  
                            var node2 = this.getNode(value2);  
                              
                            node1.edges.push(node2);  
                              
                            if (!this.directed) {  
                            node2.edges.push(node1);  
                            }  
                            }  
                            ```
        - Trees
            - What is a tree?
                - A data structure where a node can have zero or more children.
                - Each node contains a value, and similar to graphs each node can have a connection between other nodes called an edge.
                - A tree is a type of graph but not all graphs are trees.
                - The top-most node is called the root.
                - The DOM, or document object model, is a tree data structure.
                - A node without children is called a leaf node.
                - The height of the tree is the distance between the farthest leaf node and the root node.
            - Binary trees
                - Full Binary Trees
                    - A full binary tree is a binary tree in which every node has exactly zero or two children (but never one).
                - Complete Binary Trees
                    - A complete binary tree is a binary tree in which all levels except the last one are full with nodes.
                - Perfect Binary Trees
                    - A perfect binary tree is a binary tree in which all levels, including the last level, are full of nodes.
                - Binary Search Trees
                    - A binary search tree is a special type of binary tree where the values of every node to the left are less than its value and the values of every node to the right are greater than its value.
            - Example (Binary Search Tree):
                - `Node`
                    - Example:  
                        ```  
                        class Node {  
                        constructor(value) {  
                        this.value = value  
                        this.leftChild = null  
                        this.rightChild = null  
                        }  
                        }  
                        ```
                - `BinaryTree`
                    - Example:  
                        ```  
                        class BinaryTree {  
                        constructor() {  
                        this.root = null  
                        }  
                        }  
                        ```
                    - `addChild(value)`
                        - If there is no root node
                            - Set the root to the new node
                        - Otherwise start traversing the tree at the root
                            - Check if the current node's value is the same as the value we want to add.
                                - If so, cancel the addition
                            - If the current node's value is greater than the value we want to add, we'll go down the left side of the tree
                                - Check if there is a left child
                                    - If not, add the new node here
                                    - If there is, set the current node to the left child and continue down the tree
                            - If the current node's value is less than the value we want to add, we'll go down the right side of the tree
                                - Check if there's a right child
                                    - If not, add the new node here
                                    - If there is, set the current node to the right child and continue down the tree
                        - Example:  
                            ```  
                            addChild (value) {  
                            // if there is no root node, insert the new node at the root  
                            if (this.root === null) {  
                            this.root = new Node(value);  
                            return;  
                            } else {  
                            // start traversing the tree at the root  
                            let currentNode = this.root;  
                            let added = false;  
                              
                            while (!added && currentNode) {  
                            // check for duplicates  
                            if (value === currentNode.value) {  
                            return "Duplicates cannot be added";  
                            }  
                            // if the node is greater than the value  
                            // we're going to go down the left side  
                            if (value < currentNode.value) {  
                            // if there's no left child, insert the new node  
                            if (currentNode.leftChild === null) {  
                            currentNode.leftChild = new Node(value);  
                            added = true;  
                            } else {  
                            // otherwise continue down the tree  
                            currentNode = currentNode.leftChild;  
                            }  
                            // if the node is less than the value  
                            // we'll go down the right side  
                            } else if (value > currentNode.value) {  
                            // if there's no right child, insert the node  
                            if (currentNode.rightChild === null) {  
                            currentNode.rightChild = new Node(value);  
                            added = true;  
                            } else {  
                            // otherwise continue down the tree  
                            currentNode = currentNode.rightChild;  
                            }  
                            }  
                            }  
                            }  
                            }  
                            ```
                    - `removeChild(value)`
                        - We need to keep track of 4 things:
                            - `currentNode` - The node we are currently checking
                            - `found` - whether or not we've found the node we want to remove
                            - `nodeToRemove` - The node we want to remove
                            - `parentNode` - The parent node of the node we want to remove
                                - We need to keep a handle on the parent node because we're going to replace the `nodeToRemove` with one of its children on the parent node
                            - Find the node that we want to remove
                                - If the current node has no children, return an error message
                                - If the value we're looking for is greater than the current node, continue down the right subtree
                                - Otherwise, continue down the left subtree
                                - If the current node's value matches, store it in the `nodeToRemove` variable
                            - If the found node is a leaf node (i.e. it has no children)
                                - replace the parent's left or right child with null
                                    - (depending on whether the found node is the parent's left or right child)
                            - If the found node has only one child
                                - replace the parent's left or right child with the found node's child
                                    - (depending on whether the found node is the parent's left or right child)
                                - ![[Screenshot 2023-09-12 at 12.56.59 PM.png]]
                            - If the found node has two children
                                - replace the parent's left or right child with the found node's right subtree
                                    - (depending on whether the found node is the parent's left or right child)
                                - traverse the found node's right subtree's left side until a node with no left child is found
                                    - i.e. as long as the current node has a left child, continue down the left side regardless of the value
                                - insert the `nodeToRemove`'s left subtree as the left child of this node
                                - ![[Screenshot 2023-09-12 at 12.57.21 PM.png]]
                                - ![[Screenshot 2023-09-12 at 12.59.03 PM.png]]
                                - ![[Screenshot 2023-09-12 at 12.59.19 PM.png]]
                        - Example:  
                            ```  
                            removeChild (value) {  
                            var currentNode = this.root;  
                            var found = false;  
                            var nodeToRemove = null;  
                            var parentNode = null;  
                              
                            // first find the node we want to remove  
                            while (!found) {  
                            // if we don't find it, return an error message  
                            if (currentNode === null || currentNode.value === null) {  
                            return "The node was not found";  
                            }  
                            // if the currentNode's value matches, we've found our node  
                            if (value === currentNode.value) {  
                            nodeToRemove = currentNode;  
                            found = true;  
                            // if value is less than the currentNode, continue down the left tree  
                            } else if (value < currentNode.value) {  
                            parentNode = currentNode;  
                            currentNode = currentNode.leftChild;  
                            // if the value is greater than the currentNode, continue down the right tree  
                            } else {  
                            parentNode = currentNode;  
                            currentNode = currentNode.rightChild;  
                            }  
                            }  
                              
                            {  
                            let nodeToRemoveIsParentsLeftChild = parentNode.leftChild === nodeToRemove;  
                              
                            // if the node has no children  
                            if (  
                            nodeToRemove.leftChild === null &&  
                            nodeToRemove.rightChild === null  
                            ) {  
                            // set the appropriate parent node's child to null  
                            if (nodeToRemoveIsParentsLeftChild) {  
                            parentNode.leftChild = null;  
                            } else {  
                            parentNode.rightChild = null;  
                            }  
                            // if the node only has a left child  
                            } else if (  
                            nodeToRemove.leftChild !== null &&  
                            nodeToRemove.rightChild === null  
                            ) {  
                            // replace the appropriate child of the parent node with the found node's left child  
                            if (nodeToRemoveIsParentsLeftChild) {  
                            parentNode.leftChild = nodeToRemove.leftChild;  
                            } else {  
                            parentNode.rightChild = nodeToRemove.leftChild;  
                            }  
                            // if the node only has a right child  
                            } else if (  
                            nodeToRemove.rightChild !== null &&  
                            nodeToRemove.leftChild === null  
                            ) {  
                            // replace the appropriate child of the parent node with the found node's right child  
                            if (nodeToRemoveIsParentsLeftChild) {  
                            parentNode.leftChild = nodeToRemove.rightChild;  
                            } else {  
                            parentNode.rightChild = nodeToRemove.rightChild;  
                            }  
                            // if the node has TWO children  
                            } else {  
                            let rightSubTree = nodeToRemove.rightChild;  
                            let leftSubTree = nodeToRemove.leftChild;  
                              
                            // replace the appropriate child of the parent node with the found node's right subtree  
                            if (nodeToRemoveIsParentsLeftChild) {  
                            parentNode.leftChild = rightSubTree;  
                            } else {  
                            parentNode.rightChild = rightSubTree;  
                            }  
                              
                            // Find the lowest free space on the left side of the  
                            // rightSubTree and add the leftSubTree  
                            let currentLeftNode = rightSubTree;  
                            let currentLeftParent;  
                            let foundSpace = false;  
                              
                            // traverse the left side of the right subtree  
                            // until you find a node with no left child  
                            while (!foundSpace) {  
                            if (currentLeftNode === null) {  
                            foundSpace = true;  
                            } else {  
                            currentLeftParent = currentLeftNode;  
                            currentLeftNode = currentLeftNode.leftChild;  
                            }  
                            }  
                              
                            // once you do, insert the leftSubTree there  
                            currentLeftParent.leftChild = leftSubTree;  
                            return "Node successfully deleted";  
                            }  
                            }  
                            }  
                            ```
    - Algorithms
        - What is an algorithm?
            - An algorithm is a set of instructions which are used to solve a problem.
        - Algorithmic complexity
            - Big-O
                - describes the worst-case performance or complexity of an algorithm
                - tells us the maximum amount of time or the maximum amount of storage this algorithm will need to execute
                - An algorithm's worst-case runtime is also called its **upper bound**
                - This can be charted on a 2 dimensional graph where
                    - x equals input size
                    - y equals amount of time or space required
                - Calculating Big-O Notation
                    - If you have nested loops, you must multiply their complexities together to find the asymptotic upper bound.
                    - The biggest caveat with understanding Big-O notation is that we drop the constants and the less-significant terms
                    - Big-O describes the long-term growth rate of functions as opposed to their absolute magnitudes.
                - O(n) - Linear Time
                    - If you have an algorithm where the duration/size required to run the algorithm grows proportionally to the size of the input, this is known as a **linear time algorithm**
                    - array operations like `.map`, `.filter`, the spread operator, `for` loops, and `.forEach` all have O(n) runtime (assuming there is no nested loop) because an action must be done for each and every item in the array
                    - ![[Screenshot 2023-09-12 at 1.01.47 PM.png]]
                - O(1) - Constant Time
                    - Describes an algorithm which will execute in the same amount of time regardless of the amount of data.
                    - ![[Screenshot 2023-09-12 at 1.02.15 PM.png]]
                - O(log n) - Logarithmic Time
                    - Describes an algorithm which is logarithmic in nature (the size of the problem decreases by half each time it runs).
                    - Binary search is logarithmic in nature: with each pass through the algorithm the amount of data is halved in size.
                    - ![[Screenshot 2023-09-12 at 1.02.32 PM.png]]
                - O(n log n) - Super-Linear Time
                    - less performant than a linear-time algorithm but more performant than an exponential algorithm.
                    - algorithms like merge sort and heap sort have O(n log n) runtime
                    - ![[Screenshot 2023-09-12 at 1.02.45 PM.png]]
                - O(n^2) - Polynomial Time
                    - describes an algorithm where the performance is directly proportional to the square of the data size
                    - This is commonly found in algorithms using two nested `for` loops, like bubble sort.
                        - The premise of bubble sort is to compare every item in an array with every other item and swap them if the item on the left is greater than the item on the right. This causes O(n^2) comparisons becaus we have to compare n elements against n other elements.
                    - ![[Screenshot 2023-09-12 at 1.03.24 PM.png]]
                - O(2^n) - Exponential Time
                    - Exponential time algorithms double with each new data point.
                    - The recursive Fibonacci algorithm (a recursive function is a function which calls itself), which finds the next number in a sequence by adding the previous two values, is an exponential algorithm.
                    - ![[Screenshot 2023-09-12 at 1.03.37 PM.png]]
                - O(n!) - Factorial Time
                    - the worst-performing algorithm
                    - The Traveling Salesman problem is a famous problem in computer science wherein the brute-force solution is O(n!).
                    - ![[Screenshot 2023-09-12 at 1.03.48 PM.png]]
            - Big-Ω (Big Omega)
                - describes the best-case performance or complexity of an algorithm
                - this best case scenario is called an algorithm's **asymptotic lower-bound**
                - Example:
                    - You have an algorithm that searches an array for a value
                    - The best-case scenario would be that the desired value is at the very first index
            - Big-θ (Big Theta)
                - describes the average case space and time complexity of an algorithm
                - Example:
                    - In the algorithm described above, the average scenario would be that the desired value is found exactly half way through the array
        - Bubble Sort
            - a sorting algorithm where each value in an array is compared to the next and swapped if the value on the left is greater than the value on the right.
            - Bubble sort is notorious for being non- performant, with a runtime of O(n^2).
            - You can use nested for-loops to code bubble sort, or a do while loop (which reads a bit cleaner and can be more performant).
            - The do-while loop solution will stop once a full pass is completed without swapping any items. This contrasts the nested for-loop solution which will test every item against every other regardless of if a swap has occurred.
            - Thus, with the do-while loop solution, even though the Big-O runtime remains O(n^2), as it’s the worst possible scenario, it’s not as likely to have a dataset which requires n^2 passes.
            - ![[Screenshot 2023-09-12 at 1.04.00 PM.png]]
            - Examples:
                - With `for` loop:  
                    ```  
                    function bubbleSortWithForLoops (arr) {  
                    for (var i = 0; i < arr.length; i++) {  
                    for (var j = 0; j < arr.length - i - 1; j++) {  
                    if (arr[j] > arr[j + 1]) {  
                    let temp = arr[j];  
                    arr[j] = arr[j + 1];  
                    arr[j + 1] = temp;  
                    }  
                    }  
                    }  
                      
                    return [arr];  
                    }  
                    ```  
                    
                - With `do` ... `while` loop:  
                    ```  
                    function bubbbleSort(arr) {  
                    var swapped = false;  
                    do {  
                    swapped = false;  
                    arr.forEach(function (item, index) {  
                    if (item > arr[index + 1]) {  
                    let temp = item;  
                    arr[index] = arr[index + 1];  
                    arr[index + 1] = temp;  
                    swapped = true;  
                    }  
                    });  
                    } while (swapped);  
                      
                    return arr;  
                    }  
                    ```
        - Merge Sort
            - Merge sort is a “divide and conquer” algorithm which means it divides its input array into two halves and recursively calls itself on each half, then merges the two sorted halves back together.
            - The time complexity of merge sort is O(n log n).
            - The `mergeSort` function is responsible for splitting the array into smaller sub-arrays while the `merge` function is the function which sorts the arrays.
            - Example:  
                ```  
                function mergeSort (arr) {  
                if (arr.length < 2) {  
                return arr;  
                }  
                  
                var middle = Math.floor(arr.length / 2);  
                var left = arr.slice(0, middle);  
                var right = arr.slice(middle);  
                  
                return merge(mergeSort(left), mergeSort(right));  
                }  
                  
                function merge (left, right) {  
                var sorted = [];  
                  
                while (left.length && right.length) {  
                if (left[0] <= right[0]) {  
                sorted.push(left.shift());  
                } else {  
                sorted.push(right.shift());  
                }  
                }  
                  
                return [...sorted, ...left, ...right];  
                }  
                ```
            - ![[Screenshot 2023-09-12 at 1.04.16 PM.png]]
        - Quick Sort
            - Like merge sort, quick sort is also a “divide and conquer” algorithm. It picks an element as a pivot element and partitions the array around the pivot.
            - There are several methods of picking a pivot element:
                - Always pick the first element
                - Always pick the last element
                - Pick a random element
                - Pick the median element
            - There are some thoughts behind which pivot is the most performant.
            - On average quick sort has a runtime of O(n log n).
            - Example:  
                ```  
                function quickSort (arr) {  
                if (array.length < 2) return arr;  
                  
                var pivotIndex = Math.floor(array.length / 2);  
                var pivot = array[pivotIndex];  
                var less = [];  
                var greater = [];  
                  
                for (let i in array) {  
                if (i !== pivotIndex) {  
                if (arr[i] > pivot) {  
                greater.push(array[i]);  
                } else {  
                less.push(array[i]);  
                }  
                }  
                }  
                  
                return [...quickSort(less), pivot, ...quickSort(greater)];  
                }  
                ```
            - ![[Screenshot 2023-09-12 at 1.04.30 PM.png]]
        - Insertion Sort
            - Insertion sort picks an element in an array and inserts it in its correct position between 0 and the element preceding it.
            - The worst case run-time for insertion sort is O(n^2), as we’ll swap every element with every other element.
            - Example:  
                ```  
                function insertionSort (arr) {  
                for (let i = 1; i < arr.length; i++) {  
                for (let j = 0; j < i; j++) {  
                if (arr[i] < arr[j]) {  
                let [item] = arr.splice(i, 1);  
                arr.splice(j, 0, item);  
                }  
                }  
                }  
                  
                return arr;  
                }  
                ```
            - ![[Screenshot 2023-09-12 at 1.04.53 PM.png]]
            - ![[Screenshot 2023-09-12 at 1.05.04 PM.png]]
            - ![[Screenshot 2023-09-12 at 1.05.15 PM.png]]
            - ![[Screenshot 2023-09-12 at 1.05.24 PM.png]]
        - Binary Search
            - Binary Search is an efficient algorithm for finding an element within a sorted list.
            - It repeatedly divides the list in half until the element is found or there are no other elements left to search.
            - If your list is already sorted, binary search takes O(log n) as the size of the array is halved each pass through.
            - But if you have to sort the array first, binary search will take O(n log n) time to complete.
            - Example:  
                ```  
                function binarySearch (list, item) {  
                list.sort((a, b) => a - b);  
                  
                var low = 0;  
                var high = list.length;  
                  
                while (low <= high) {  
                let mid = Math.floor((low + high) / 2);  
                let guess = list[mid];  
                  
                if (guess === item) return true;  
                if (guess < item) {  
                low = mid + 1;  
                } else {  
                high = mid - 1;  
                }  
                }  
                  
                return false;  
                }  
                ```  
                
            - ![[Screenshot 2023-09-12 at 1.05.38 PM.png]]
        - Tree Traversals
            - In-Order
                - With an in-order traversal, we visit the current node in the order it would naturally fall (left child, current node, right child).
                - ![[Screenshot 2023-09-12 at 1.05.59 PM.png]]
            - Pre-Order
                - With a pre-order traversal, we visit the current node before visiting the child nodes (current node, left child, right child).
                - ![[Screenshot 2023-09-12 at 1.06.07 PM.png]]
            - Post-Order
                - With a post-order traversal, we visit the current node after visiting the child nodes (left child, right child, current node).
                - ![[Screenshot 2023-09-12 at 1.06.17 PM.png]]
            - Example:  
                ```  
                function inOrder (node, fn) {  
                if (node !== null) {  
                inOrder(node.leftChild, fn);  
                fn(node);  
                inOrder(node.rightChild, fn);  
                }  
                }  
                  
                function preOrder (node, fn) {  
                if (node !== null) {  
                fn(node);  
                inOrder(node.leftChild, fn);  
                inOrder(node.rightChild, fn);  
                }  
                }  
                  
                function postOrder (node, fn) {  
                if (node !== null) {  
                inOrder(node.leftChild, fn);  
                inOrder(node.rightChild, fn);  
                fn(node);  
                }  
                }  
                ```
        - Tree Search
            - Depth-First
                - In depth-first search we travel as far down each branch (starting with the left) as possible before moving on to the right branch.
                - We can use a hash array to track whether we’ve visited a node before.
                - Example (On a graph):  
                    ```  
                    function depthFirstSearch (graph, startValue) {  
                    var startNode = graph.getNode(startValue);  
                    var visitedNodesHash = graph.nodes.reduce(function (acc, cur) {  
                    acc[cur.value] = false;  
                    return acc;  
                    }, {});  
                      
                    function exploreNode (node) {  
                    if (visitedNodesHash[node.value]) return;  
                    visitedNodeHash[node.value] = true;  
                    node.edges.forEach((edge) => exploreNode);  
                    }  
                      
                    exploreNode(startNode);  
                    }  
                    ```
                - ![[Screenshot 2023-09-12 at 1.06.45 PM.png]]
            - Breadth-First
                - In breadth-first search we explore all nodes on the same tree level before moving to a deeper level.
                - We can use a queue to keep track of the nodes we still have to visit.
                - Example (in a graph):  
                    ```  
                    function breadthFirstSearch (graph, startValue) {  
                    var startNode = graph.getNode(startValue);  
                    var visitedNodesHash = graph.nodes.reduce(function (acc, cur) {  
                    acc[cur.value] = false;  
                    return acc;  
                    });  
                      
                    var queue = new Queue();  
                    queue.enqueue(startNode);  
                      
                    while (!queue.isEmpty()) {  
                    let currentNode = queue.dequeue();  
                    if (!visitedNodesHash[currentNode.value]) {  
                    visitedNodesHash[currentNode.value] = true;  
                    }  
                      
                    currentNode.edges.forEach(function (node) {  
                    if (!visitedNodesHash[node.value]) {  
                    queue.enqueue(node);  
                    }  
                    });  
                    }  
                    }  
                    ```
                - ![[Screenshot 2023-09-12 at 1.06.56 PM.png]]
    - Systems Design
        - Here are some specific areas of systems design that you should study up on to prepare for your systems design interviews.
            - Key characteristics of distributed systems
            - SQL vs. NoSQL databases
            - Load balancers
            - Caching
            - Data partitioning
            - Replication / redundancy
            - Database schemas
        - Foundations Of Systems Design
            - Distributed Systems
                - A distributed system is a system with many components that are located on different machines
                - These machines communicate with one another to complete tasks such as adding a new user to the database and returning data from API requests.
                - Despite being a distributed system with many moving parts, the user sees one cohesive process.
            - Characteristics Of Distributed Systems
                - Scalability
                    - For a system to be scalable it must be able to adapt to growing demand whether that demand is number of users or an increase in network requests.
                    - Horizontal Scaling
                        - Adding more servers to the pool of resources
                        - Horizontal scaling might be easier than vertical scaling as you can purchase a new server and have it up and running quickly.
                    - Vertical Scaling
                        - Vertical scaling, in contrast, requires adding more power, such as CPU (Central Processing Unit) or RAM (Random Access Memory), to your existing servers.
                        - Often much more difficult to achieve as you’re limited to a single server, so scaling past that server’s capability often requires downtime and has an upper-bound.
                - Reliability / Fault Tolerance
                    - The probability that a system will fail during a given period of time.
                    - A system is reliable if it continues functioning when its hardware or software fails.
                - Load Balancing
                    - Distributes traffic to servers and monitors the status of the servers while distributing traffic.
                    - If a server suddenly becomes unavailable to accept new requests, the load balancer will prevent new requests from reaching that server.
                    - sit between the client and the server
                    - use various algorithms to determine how traffic should be distributed to different servers
                    - By distributing traffic, load balancers prevent any individual server from being inundated with requests.
                    - Load Balancing Algorithms
                        - Least Connection Method
                            - Distributes traffic to the server with the least active connections.
                        - Least Response Time Method
                            - Distributes traffic to the server with the least amount of active connections and the quickest average response time.
                        - Lowest Bandwidth Method
                            - distributes traffic to the server that is currently serving the least amount of traffic (measured in megabits per second, or Mbps).
                        - Round Robin Method
                            - terates through each server and sends each new request to the next server. When the last server in the cluster is reached, the load balancer starts over from the first server in the cluster.
                        - Weighted Round Robin Method
                            - very similar to the round robin algorithm with one distinction: it can account for servers with different processing capabilities.
                            - Every server in the cluster is assigned a weight that indicates its processing capability and servers with higher weights receive new connections before servers with lower weights.
                        - IP Hash Method
                            - The IP hash method calculates the IP address of the requesting client and using this IP hash redirects the request to a server.
                - Caching
                    - What is caching?
                        - Caching is the process of saving responses to be quickly served the next time that response is requested.
                    - Cache Invalidation
                        - Having an appropriate cache invalidation method is extremely important because space in the cache is limited
                        - Cache-Invalidation Methods
                            - Write-Through Cache
                                - data is saved in cache as well as its corresponding database simultaneously which allows for quick retrieval.
                                - pros
                                    - having cache and database parity ensures consistency, making the system more secure in the event of a power failure or system error.
                                - cons
                                    - each operation must be done twice (once in cache and once in the database) before it sends the response to the client so there is higher latency than other cache invalidation methods.
                            - Write-Around Cache
                                - Write directly to the database and ignore cache completely
                                - pros
                                    - can prevent the cache from being inundated with write operations
                                - cons
                                    - the next time a read request is made for a piece of data it will cause a cache-miss and the response must be read from permanent storage.
                            - Write-Back Cache
                                - write solely to cache before sending the response to the client
                                - pros
                                    - provides the lowest latency
                                - cons
                                    - can lead to data loss in the event of system failure as we only write data from cache to permanent storage at particular intervals.
                    - Cache Eviction Policies
                        - First-In-First-Out
                            - the first-accessed block is evicted regardless of how often it's accessed
                        - Last-In-First-Out
                            - the most recently-accessed block is evicted regardless of how often it's accessed.
                        - Least Frequently Used
                            - the least frequently accessed block is evicted.
                        - Most Frequently Used
                            - the most frequently accessed block is evicted.
                        - Least Recently Used
                            - the least recently accessed block is evicted.
                        - Most Recently Used
                            - the most recently accessed block is evicted.
                        - Random Replacement
                            - a random block is evicted.
                - Data Partitioning
                    - the method by which a large database is segmented
                    - Data Partitioning Methods
                        - Horizontal Partitioning
                            - (also known as range-based partitioning and data sharding)
                            - different rows are placed into different tables
                            - can lead to unbalanced servers
                                - perhaps there are hundreds more students with "F" last names than students with "Q" last names
                        - Vertical Partitioning
                            - data is separated by schema
                            - related data is stored within the same table
                            - inability to scale when the data becomes too large
                - SQL vs. NoSQL Databases
                    - SQL (or Relational) Databases
                        - store data in rows, columns, and tables.
                        - A row includes information about one specific entity
                        - A column includes information about each different data points
                    - NoSQL (or Non-Relational) Databases
                        - Graph Databases
                            - data is stored using the graph data structure (nodes with edges)
                        - Document Databases
                            - Data is stored in documents which are grouped into collections where each document can have its own structure
                        - Wide-Column Databases
                            - data is stored in a column family, which is similar to a container for rows.
                        - Key-Value Databases
                            - Data is stored in an array of key-value pairs where the key is an attribute and it's linked to a value.
                - Redundancy & Replication
                    - Redundancy
                        - The process of duplicating pieces of your system or functionality of the system in order to improve its reliability
                        - Having a redundant system prevents a single point of failure.
                    - Replication
                        - The sharing of information to ensure a redundant system is consistent
        - Tips For Systems Design Interviews
            - Systems design interviews for front-end developers seem to be less data-focused (how many terabytes of storage will we need?) and more architecturefocused (what is a good data-partitioning method given the needs of our application?).
            - Ask clarifying questions
            - List functional and non-functional requirements:
                - If designing Twitter, for example, a functional requirement would be that users should be able to follow other users and post new tweets. A non-functional requirement may be that the system must be highly available; our system might want to prioritize replication of data.
            - If you’re unsure where to start, ask!
            - If you’re unclear about something say “I am not sure how to proceed with this, I know it’s not correct, but I will come back to this if I have time at the end and will move on to X.”
            - start with the functional and non-functional requirements and approaching the interview as more of a conversation than a quiz.
        - Example System Design Interview Questions
            - How would you design Instagram?
            - How would you design Twitter?
            - How would you design a real-time chat application?
    - Utility functions
        - The front-end version of LeetCode questions, but with less emphasis on complicated algorithms and more focused to practical use cases.
        - Almost all existing utilty functions asked exist within JavaScript core or famous third-party libraries like Lodash, with the most famous being debounce and throttle.
        - The best way to prepare is to get your hands dirty by implementing them yourself and writing test cases for them.
        - Because you're writing functions, pay attention to the time complexity as well.
        - Candidates are expected to take just around 10-15 minutes for a basic question.
        - If you can tell that you received a basic question, try to finish within the suggested duration and do not intentionally take the entire interview to do one question.
        - In most cases, you are expected to answer another small coding question.
        - Basic examples​
            - debounce()/throttle()
            - cloneDeep()
            - groupBy()
            - chunk()/map() then mapAsync(Promise.all) then mapWithChunksAsync
            - Convert all keys within an object into snake_case/camelCase
            - document.querySelectorAll (limited to just tags selectors)
            - [Observer pattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript)
        - Advanced examples​
            - Advanced questions are usually given to more senior candidates and expect around 25-30 minutes to complete or arrive at a minimally working solution.
                - Write a templating engine that does variables substitution and simple conditionals
                - Implement JSON.stringify
                - Generate table of contents/outline from a DOM similar to Google Docs
        - Tips​
            - Always try to write pure functions
            - If you're writing a recursive function, ask whether there's a maximum stack depth limit
            - Some nested data structures can have recursive references to itself. Do clarify that there are no self-references/cycles within the object/ask if you need to handle them (usually the answer is No)
    - Building UI Interfaces
        - Companies usually ask candidates to code in one of these three ways:
            - [Codepen](https://codepen.io/) (or some other online editor with preview)
            - BYOE (Bring your Own Environment) - You bring your own dev env and laptop and can work either locally or in a sandbox
                - Usually only done on-site
                - You can usually use a JavaScript framework/library
                    - use tools that help you scaffold a fresh app immediately (e.g. create-react-app, vue-cli).
                    - don't spend time during the interview doing unnecessary plumbing that doesn't give your interviewers additional useful signals
            - Whiteboard - You write all the required HTML, JS, CSS on a whiteboard.
        - Examples​
            - Components
                - Tabs
                - Accordion
                - Photo gallery
                - Other possible components - [Bootstrap](https://getbootstrap.com/docs/4.0/components/)
            - Apps
                - Sortable Data Table (with extensions for filtering)
                - TODO list
                - Kanban Board
            - Games
                - Tic-tac-toe Game
                - Whack-a-mole Game
                - Tetris Game (advanced)
                - Snake Game (advanced)
        - Considerations
            - Front end best practices​
                - What if I need to have multiple instances of this components on the page?
                - Will having my components on the same page affect each other?
                - Do I have a convenient API to instantiate independent components with configurable options?
                    - Old school jQuery UI components are a good examples of this.
            - Performance and scalability​
                - What if the network takes too long to return something?
                - What if a string is too long?
                - What if a picture is too large?
                - Can the component contain any amount of child items?
                    - Will the layout be messed up if I have too few or too many of these items?
                    - What if there are no items, what empty state do I show?
                - How will performance be affected if I have too many elements on the page?
                - Did I hard code any values that will make it hard to extend to changing requirements in future?
                - Did I design for extensibility?
            - Network requests​
                - Does the component deal with race conditions in network/async requests?
                - What if the request timeout or errored? How can I recover from it gracefully?
                - How can I improve the performance of the component? Can I make use of caching, lazy loading, prefetching/preloading?
                - What if I need to load a lot of data/images? Can I lazily load them? Can I fetch the data in batches to reduce spamming the API endpoint?
            - User experience​
                - Is my component mobile-friendly? Can my component fit on different screen widths? How do I make it mobile-friendly?
                - Is my component easily i18n-able? How can I change the design to cater for i18n? Does my component support RTL languages?
                - Are there any potential UX/accessibility (a11y) issues with my components?
                - What are some common accessibility techniques and gotchas?
                    - https://medium.com/@addyosmani/accessible-ui-components-for-the-web-39e727101a67
                - What tools can I use to check for accessibility?
                - There's probably isn't much time for you to be an expert in a11y but knowledge of a11y is one of the differentiating factors between junior vs senior engineers.
            - Security
                - XSS vulnerability.
                    - Interviewers are especially looking out for this whenever there is user input involved.
                    - You almost never need to use .innerHTML or $.html() function. If you do, make sure you escape the contents first.
                - User input that is being displayed in the URL has to be encoded first as well, or else there's also a potential for mischief.​
            - Future
                - mention how you would do things differently if you had more time and were writing production code that you need to maintain.
                - Perhaps...
                    - use Sass instead of CSS
                    - use React instead of jQuery for better maintainability
                    - make the component mobile-friendly and test on different screen widths
                    - add keyboard shortcuts
                    - etc.
    - Frontend Systems Design
        - Many of the topics mentioned in the "building ui interfaces" format are also relevant for front end system design - API design, scalability, performance, user experience, i18n, accessibility, security. Candidates should take the initiative and bring these topics up and lead the discussion with the interviewer.
        - The more advanced topics such as performance, accessibility and i18n are what differentiates senior candidates from the junior ones.
        - The two main kinds of front end system design interviews are UI components and applications.
        - Examples​
            - UI Components
                - Photo gallery
                - Selector which loads options over the network
                - Image carousel
            - Applications
                - News feed
                - Video watching website
                - Chat application
        - System design interview questions tend to be open ended and vague, leaving you with lots of room to explore. If the interviewer tells you which specific areas to focus on, that's great! Otherwise, here's a framework you can consider for front end interviews, which is also helpful when working on new front end projects at work.
            - Requirements clarifications/alignment
            - Architecture
            - Data Model Design
            - API Design
            - Extra Stuff
                - Multi-device support
                - User Experience
                - Performance
                - Accessibility
                - i18n
                - Security
        - UI Components
            - Some considerations:
                - What devices should the system support? Desktop web, mobile web, etc
                - What's the primary device that users will access the system on?
                - Which browsers should we support?
                - Do we need to support internationalization?
                - How much styling customization do we want to allow?
            - Architecture​
                - list down the various sub-components that will exist within it, what data is being passed among each component
            - Data model​
                - Data model for components will refer to the component state.
                    - State is allowed to change over time during the lifecycle of the component, typically as a result of user interactions
                    - Each component has its own state which allows _multiple instances_ of the component to coexist on a single page. The state of a component instance should not affect the state of another instance
                    - Components are easier to reason about (read/understand) the less state there is. We should strive to reduce the amount of state needed. If a component uses a value which can be derived from another piece of state, then that value should most likely not be part of the state. For example if your component is rendering a list of items and you want to display a message when there are no items to render, there shouldn't be an additional isEmpty state because it can be derived from the length of the items
                    - If a component has multiple sub-components, it'll be best if it's possible to consolidate the state within the top level and the rest of the components are pure and stateless
            - API design​
                - For components, API refers to configuration options which would the component developer would expose to other developers to specify.
                - What are the configuration options you would allow for the component? (props in React). What would be reasonable defaults?
                - Follow Open-closed principle - the component should be open for extension but closed for modification. In React,
                - If your component is meant to be a UI library that doesn't bother about the appearance and leaves the styling to the user, extra care has to go into the design of the props and to allow users to customize the look and feel of the components. There are a few ways to go about this in React:
                    - [Composition](https://reactjs.org/docs/composition-vs-inheritance.html) - Props which accept React components which also promotes code reuse
                    - [Render props](https://reactjs.org/docs/render-props.html) are function props that a component uses to know what to render. It also helps in reusing behavior without bothering about the appearance
                    - className or style props - Allows users to inject class namaes and/or styling attributes to inner DOM elements
                - Possible configuration options:
                    - Lifecycle/event hooks - click, blur, etc
            - Deep dives​
                - Note that there almost definitely won't be enough time to cover every area, and not every area will be very relevant to the component at hand.
                - Showing knowledge about these areas and being able to dive deep into them are traits of senior developers.
                - User experience (UX)​
                    - Reflect state of the component to the user - If there's a pending background request, show a spinner. If there's an error, make sure to display it instead of silently failing
                    - Display an empty state if there are no items in a list instead of not rendering anything
                    - Destructive actions should have a confirmation step, especially irreversible ones
                    - Disable interactive elements if they trigger an async request! Prevents double firing of events
                    - If there are search inputs involved, each keystroke should not fire a network request
                    - Handle extreme cases
                        - Strings can be really long/short and your UI should not look weird in either case. For long strings, they can have their contents truncated and hidden behind a "View more" button
                        - If there are many items to display within a component, they shouldn't all be displayed on the screen at once and making the page extremely long/wide. Paginate the items or contain them within a container with a maximum width/height
                - Performance
                    - In front end, performance typically refers to a few things - loading speed, how fast the UI responds to user interactions, memory space (heap) required by the component.
                    - Loading speed - The less JavaScript the component contains, the less JavaScript the browser has to download to load the component and the lower the network request time. It's also important to modularize components and allow users to download only the necessary JavaScript modules needed for their use case.
                    - Responsiveness to user interactions
                        - If a user interaction results in displaying of data that has to be loaded over the network, there will be a delay between the user interaction and updating of the UI. Minimizing that delay or removing it entirely is the key to improving responsiveness.
                        - JavaScript in a browser is single-threaded. The browser can only do execute one line of code at any one time. The less work (JavaScript executed, DOM updates) the component has to do when a user does something on the page, the faster the component can update the UI to respond to the changes.
                    - Memory space - The more memory your component takes up on the page, the slower the browser performs and the experience will feel sluggish/janky. If your component has to render hundreds/thousands of items (e.g. number of images in a carousel, number of items in a selector), memory space might become significant.
                    - Optimization tips
                        - Render only what is displayed on the screen - For example, in a selector, only a few items are displayed to the user even if the list can contain hundreds of elements. Rendering all of them into the browser would be a waste of processing power and memory space. We can leverage a technique called windowing/virtualization to emulate a list with many elements while only rendering a few as possible to make the final result look as if there was no optimization done (especially preserving scroll height). Read more about virtualization [here](https://web.dev/virtualize-long-lists-react-window/).
                        - Lazy loading/load only necessary data - For example, in a photo gallery component, a user can have hundreds and thousands of photos, but it won't be feasible to load all of them eagerly. Most likely the user won't be browsing all of them in that session too. An optimization could be to load only the ones that the user is likely to view, or those that are within the viewport (which we call "above the fold"). The rest of the photos can be loaded on demand, which introduces responsiveness delay, but the next tip will help you to handle that.
                        - Preloading/prefetching data ahead of time - For example, in an image carousel where there are too many images to load beforehand, an optimization could be to load the next image ahead of time while the user is still on the current image, such that when the user clicks the "Next" button, there's no network delay needed because the next image has already been loaded. This technique can also be modified to load the next N images to handle the case where users click "Next" in rapid succession.
                - Accessibility (a11y)​
                    - Accessibility (a11y) is the practice of making your websites usable by as many people as possible.
                        - Color contrasts (e.g. color blindness)
                        - Keyboard friendliness (e.g. people with limited fine motor control)
                        - Visual Impairment (e.g. blind)
                        - Transcripts for audio (e.g. deaf)Not everyone surfs the web the same way; some people use screenreaders and keyboards exclusively (no mouse)! Here are some basic tips for achieving a11y in UI components:
                        - Foreground colors should have sufficient contrast from the background colors
                        - Use the right HTML tags for semanticness, or the right aria-role attributes
                        - Clickable items should have tabindex attribute (so that they are focusable) and also "cursor: pointer" styling to indicate that they can be clicked on
                        - Images should have alt text, which will be read out by screen readers and act as a fallback description if the image fails to load
                        - aria-labels help to provide context to elements which are non-obvious to non-visual users. E.g. an icon button without any text label within it should have an aria-label attribute so that the intention is clear for users who can't see the icona11y is one of the most commonly neglected areas as most of the time they're invisible to the developer. Showing knowledge of a11y and possessing the skills to create accessible components will definitely reflect well on you. More reading on [Web Accessibility](https://www.w3.org/WAI/fundamentals/accessibility-intro/).
                - Internationalization (i18n)​
                    - Internationalization (i18n) is the design and development of a product, application or document content that enables easy localization for target audiences that vary in culture, region, or language. Typically components shouldn't have to worry about i18n unless under few specific circumstances:
                        - Component uses strings - Strings used in the component shouldn't be hardcoded to a specific language (e.g. "Prev"/"Next" in the controls of a photo gallery component). The strings can be specified as a prop with the English version as default
                        - Order of content matters - Does your component support RTL (right to left) languages like Arabic and Hebrew?
                - Multi-device support​
                    - Is the component expected to be used on mobile web? Mobile devices have unique constraints - they have less powerful hardware and viewport size is smaller. Hence things could be done differently to allow the component to work better on mobile devices - making a conscious effort to:
                        - Not use too much memory - using too much memory makes the device perform slower
                        - Increasing the hit box of interactive elements - fingers have an easier time tapping on the right element
                - Security​
                    - Most of the time, components aren't exposed to security vulnerabilities, but it can still happen. Here are the more common security vulnerabilities you should be aware of:
                        - XSS - Is your component vulnerable to cross-site scripting (XSS)? E.g. Do you render user input via .innerHTML or dangerouslySetInnerHTML (React-specific)?
                        - CSRF (Cross-Site Request Forgery)
                        - Clickjacking
                        - [rel=noopener](https://mathiasbynens.github.io/rel-noopener/)
- Resources
    - Preparing:
        - ~~De-coding the technical interview process #project-management/story~~
        - [Preparing for a Front-End Web Development Interview in 2017](http://davidshariff.com/blog/preparing-for-a-front-end-web-development-interview-in-2017/)
        - ~~[Cracking the front-end interview](https://medium.freecodecamp.com/cracking-the-front-end-interview-9a34cd46237) #project-management/story~~
        - [Front End Interview Handbook](https://github.com/yangshun/front-end-interview-handbook)
        - ~~[Decoding the Front-end Interview Process](https://dev.to/emmawedekind/decoding-the-front-end-interview-process-14dl) #project-management/story~~
        - https://www.crackingthecodinginterview.com/
        - https://www.educative.io/courses/grokking-the-behavioral-interview?aff=x23W
        - https://techinterviewhandbook.org/behavioral-round-overview/
        - https://www.educative.io/path/ace-javascript-coding-interview?aff=x23W
    - Coding Practice
        - https://frontendeval.com/
        - Leetcode
        - Hackerrank
        - Project Euler
        - Code Wars
        - Top Coder
        - Coderbyte
        - Exercism
        - Practice recreating layouts from Dribbble
            - When you’re preparing for your interview, try code most of your layout _without_ looking at the result till the end.
    - Quizzes:
        - [Front End Web Development Quiz](http://davidshariff.com/quiz/)
        - [JavaScript Web Quiz](http://davidshariff.com/js-quiz/)
    - Questions you may get asked:
        - https://www.frontendinterviewhandbook.com/javascript-questions
        - https://www.frontendinterviewhandbook.com/html-questions
        - https://www.frontendinterviewhandbook.com/css-questions
        - https://www.guru99.com/javascript-interview-questions-answers.html
        - https://www.codementor.io/@nihantanu/21-essential-javascript-tech-interview-practice-questions-answers-du107p62z
        - https://www.toptal.com/javascript/interview-questions
        - [Front-end Developer Interview Questions](https://github.com/h5bp/Front-end-Developer-Interview-Questions)
        - [Front-end Interviews](https://frontendmasters.com/books/front-end-handbook/2018/practice/interview-q.html)
        - [Clearing Your Front End Job Interview - JavaScript](https://codeburst.io/clearing-your-front-end-job-interview-javascript-d5ec896adda4)
        - [10 Interview Questions Every JavaScript Developer Should Know](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95)
        - [Front-End Job Interview Questions](http://h5bp.github.io/Front-end-Developer-Interview-Questions/)
        - [Front End Web Development Quiz](http://davidshariff.com/quiz/)
        - [Interview Questions for Front-End-Developer](http://thatjsdude.com/interview/index.html)
        - [The Best Frontend JavaScript Interview Questions (written by a Frontend Engineer)](https://performancejs.com/post/hde6d32/The-Best-Frontend-JavaScript-Interview-Questions-(Written-by-a-Frontend-Engineer))
    - Questions you ask:
        - [An open source list of developer questions to ask prospective employers](https://github.com/ChiperSoft/InterviewThis)